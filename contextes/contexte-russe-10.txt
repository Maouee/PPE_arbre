   vk.com/eugzol
   Главная / Программирование → Создаём язык программирования → Лекция Г2.
   Абстрактное синтаксическое дерево (AST)

Определение
--
   Возьмём арифметическое выражение 1 + (2 * 3).

   Абстрактным синтаксическим деревом (abstract syntax tree, AST) для него
   будет следующее:

   Ast

   Абстрактное синтаксическое дерево выражения 1 + (2 * 3).

   Объясним словосочетание «абстрактное синтаксическое дерево» по частям.

   «Дерево» — см. рисунок.

   «Синтаксическое» — значит, отражает структуру (синтаксис) исходного
   выражения. А именно, узлы дерева соответствуют операциям (сложению и
   умножению), а листья соответствуют операндам (числам). Каждый узел дерева
   отражает конкретную операцию исходного выражения (и наоборот).

   «Абстрактное» — дерево «очищено» от вспомогательных символов,
   использующихся в исходной строке (для данного примера  — отсутствуют
   скобки).

   Итак, абстрактное синтаксическое дерево — дерево, отражающее структурные
   связи между существенными элементами исходного выражения (строкой
   рассматриваемого языка), но не отражающее вспомогательные языковые
--
AST и естественный язык

   Несколько упрощая, абстрактным синтаксическим деревом предложения

 Мама мыла раму
--
   Ast natural

   «Абстрактное синтаксическое дерево» предложения на русском языке

   Предикат (то есть глагол) стоит в узле. Его референты (в математике мы их
--
AST vs parse tree

   Важно не путать «абстрактное синтаксическое дерево» и «дерево парсинга»
   (parse tree).

   Собственно, у них одно отличие: дерево парсинга «конкретно», то есть
   содержит все вспомогательные языковые средства.

   А абстрактное (= очищенное) синтаксическое дерево содержит то и только то,
   что существенно для понимания предложения (в языках программирования под
   «пониманием» имеется в виду вычисление/выполнение).
--
    [:paren, [[:binary, [:@int, "2", [1, 5]], :*, [:@int, "3", [1, 9]]]]]]]]

   В виде дерева вот как выглядит:

   Ripper parse tree
--

   Нужна ли эта информация для вычисления выражения? Нет, не нужна, так как в
   дереве и так видно, что первым выполняется умножение (оно стоит на более
   низком уровне дерева), а следом сложение (которое использует в правой
   ветке результат умножения).

   Логика такая: детали языковых средств записи попали в дерево. Значит, это
   не «абстрактное» дерево. Значит, это не AST, а parse tree.

   На AST смотри выше.
--

   Концептуальной разницы это не создаёт. Без ограничения общности мы все
   такие варианты будем назвывать «абстрактными синтаксическими деревьями»,
   хотя это может быть не буквальный рисунок дерева, а массив (структура
   данных внутри языка разработки парсера), линейный текст, либо
   последовательность зарядов электронов на SSD-диске.
--
   Дерево парсинга для строки “multiply(2,5)” в заданной грамматике

   Итак, дерево парсинга (parse tree) однозначно отображает, какие правила
   вывода и в каком порядки были применены и каким терминалам исходной строки
   сопоставлены.
--
   В методе рекурсивного нисходящего парсинга синие узлы соответствуют вызову
   функции, обрабатывающей указанный нетерминал, а белые узлы — «снятию»
   (shift) символа с входной ленты. Обход дерева сверху вниз и слева направо
   соответствует порядку операций при данном методе парсинге.

--
   Function call ast

   Абстрактное синтаксическое дерево для строки “multiply(2,5)” выбранной
   структуры

--
     * переименовать некоторые узлы;
     * удалить «служебные» узлы;
     * свернуть порождённое рекурсией поддерево <arguments> в линейный
       список/массив.

--

   • Г1: Нормальная форма Бэкуса (BNF)
   • Г2: Абстрактное синтаксическое дерево (AST)

   Языки:
